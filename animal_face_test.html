<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë™ë¬¼ìƒ í…ŒìŠ¤íŠ¸</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
</head>
<body>
    <div class="theme-toggle-container">
        <button id="theme-toggle">Toggle Theme</button>
    </div>
    <div class="container">
        <h1>ë™ë¬¼ìƒ í…ŒìŠ¤íŠ¸ ğŸ¾</h1>
        <p>ë‹¹ì‹ ì€ ê°•ì•„ì§€ìƒ? ê³ ì–‘ì´ìƒ? ì§€ê¸ˆ ë°”ë¡œ í™•ì¸í•´ë³´ì„¸ìš”!</p>

        <div class="input-selection">
            <button class="select-btn active" id="webcam-mode-btn">ì›¹ìº ìœ¼ë¡œ ì´¬ì˜</button>
            <button class="select-btn" id="upload-mode-btn">ì´ë¯¸ì§€ íŒŒì¼ ì²¨ë¶€</button>
        </div>

        <div id="webcam-section" class="input-section">
            <div id="webcam-container"></div>
            <button type="button" onclick="initWebcam()" class="action-btn generate-btn">ì›¹ìº  ì‹œì‘</button>
            <button type="button" onclick="stopWebcam()" class="action-btn generate-btn hidden" id="stop-webcam-btn">ì›¹ìº  ì •ì§€</button>
        </div>

        <div id="upload-section" class="input-section hidden">
            <input type="file" id="image-upload" accept="image/*">
            <img id="image-preview" src="#" alt="Image Preview" style="display:none; max-width:200px; max-height:200px; object-fit: contain; margin: 10px auto;">
            <button type="button" onclick="predictImage()" class="action-btn generate-btn">ì´ë¯¸ì§€ë¡œ íŒë³„</button>
        </div>

        <div id="loading" class="loading-spinner" style="display:none;"></div>
        
        <div id="result-section" style="display:none;">
            <h2>íŒë³„ ê²°ê³¼</h2>
            <div id="label-container"></div>
            <div id="chart-container" class="chart-container">
                <canvas id="predictionChart"></canvas>
            </div>
        </div>

        <a href="index.html" class="nav-link">í™ˆìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="text/javascript">
        const URL = "https://teachablemachine.withgoogle.com/models/8Vat-gajw/";
        let model, webcam, maxPredictions;
        let labelContainer;
        let chart;
        let currentSource = 'webcam'; // 'webcam' or 'upload'

        // Theme switching logic
        document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('theme-toggle');
            function applyTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                const isDarkMode = savedTheme === 'dark';
                document.body.classList.toggle('dark-mode', isDarkMode);
                updateChartTheme(); // Update chart theme as well
            }
            applyTheme();
            if(themeToggle){
                themeToggle.addEventListener('click', () => {
                    const isDarkMode = document.body.classList.toggle('dark-mode');
                    const newTheme = isDarkMode ? 'dark' : 'light';
                    localStorage.setItem('theme', newTheme);
                    applyTheme(); // Re-apply theme to update chart
                });
            }

            // Input mode selection
            document.getElementById('webcam-mode-btn').addEventListener('click', () => switchInputMode('webcam'));
            document.getElementById('upload-mode-btn').addEventListener('click', () => switchInputMode('upload'));
            document.getElementById('image-upload').addEventListener('change', handleImageUpload);
        });

        async function loadModel() {
            if (model) return; // Model already loaded
            document.getElementById('loading').style.display = 'block';
            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";
            model = await tmImage.load(modelURL, metadataURL);
            maxPredictions = model.getTotalClasses();
            document.getElementById('loading').style.display = 'none';
        }

        async function initWebcam() {
            await loadModel(); // Ensure model is loaded

            if (webcam && webcam.streaming) { // If webcam is already running, stop it
                webcam.stop();
                document.getElementById("webcam-container").innerHTML = '';
            }
            
            document.getElementById('loading').style.display = 'block';
            const flip = true;
            webcam = new tmImage.Webcam(200, 200, flip); // width, height, flip
            await webcam.setup(); // request access to the webcam
            await webcam.play();
            document.getElementById("webcam-container").appendChild(webcam.canvas);
            document.getElementById('stop-webcam-btn').classList.remove('hidden');
            document.getElementById('loading').style.display = 'none';
            window.requestAnimationFrame(loopWebcam);
        }

        function stopWebcam() {
            if (webcam && webcam.streaming) {
                webcam.stop();
                document.getElementById("webcam-container").innerHTML = '';
                document.getElementById('stop-webcam-btn').classList.add('hidden');
            }
        }

        async function loopWebcam() {
            if (!webcam || !webcam.streaming) return; // Stop looping if webcam is stopped
            webcam.update();
            await predict(webcam.canvas); // Predict from webcam
            window.requestAnimationFrame(loopWebcam);
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.getElementById('image-preview');
                    img.src = e.target.result;
                    img.style.display = 'block';
                    // Clear previous results when new image is uploaded
                    clearResults();
                }
                reader.readAsDataURL(file);
            }
        }

        async function predictImage() {
            await loadModel(); // Ensure model is loaded
            
            const img = document.getElementById('image-preview');
            if (img.style.display === 'none' || !img.src || img.src === '#') {
                alert('ì´ë¯¸ì§€ íŒŒì¼ì„ ë¨¼ì € ì²¨ë¶€í•´ì£¼ì„¸ìš”.');
                return;
            }
            document.getElementById('loading').style.display = 'block';
            const prediction = await model.predict(img);
            displayResults(prediction);
            document.getElementById('loading').style.display = 'none';
        }

        async function predict(imageSource) {
            if (!model) return;
            const prediction = await model.predict(imageSource);
            displayResults(prediction);
        }

        function switchInputMode(mode) {
            currentSource = mode;
            if (mode === 'webcam') {
                document.getElementById('webcam-section').classList.remove('hidden');
                document.getElementById('upload-section').classList.add('hidden');
                document.getElementById('webcam-mode-btn').classList.add('active');
                document.getElementById('upload-mode-btn').classList.remove('active');
                clearResults();
                // Optionally start webcam automatically if user was in webcam mode before
                // initWebcam(); 
            } else { // upload mode
                document.getElementById('webcam-section').classList.add('hidden');
                document.getElementById('upload-section').classList.remove('hidden');
                document.getElementById('webcam-mode-btn').classList.remove('active');
                document.getElementById('upload-mode-btn').classList.add('active');
                if (webcam && webcam.streaming) {
                    stopWebcam();
                }
                clearResults();
            }
        }

        function clearResults() {
            document.getElementById('result-section').style.display = 'none';
            if (labelContainer) labelContainer.innerHTML = '';
            if (chart) chart.destroy();
        }

        function displayResults(prediction) {
            clearResults(); // Clear previous results
            document.getElementById('result-section').style.display = 'block';
            
            const labels = prediction.map(p => p.className);
            const probabilities = prediction.map(p => parseFloat(p.probability.toFixed(2)));

            // Update text labels
            if (labelContainer) {
                labelContainer.innerHTML = '';
                prediction.forEach(p => {
                    const div = document.createElement('div');
                    div.textContent = `${p.className}: ${(p.probability * 100).toFixed(0)}%`;
                    labelContainer.appendChild(div);
                });
            }

            // Update chart
            const ctx = document.getElementById('predictionChart').getContext('2d');
            const chartColors = ['rgba(75, 192, 192, 0.6)', 'rgba(255, 99, 132, 0.6)', 'rgba(255, 206, 86, 0.6)', 'rgba(153, 102, 255, 0.6)']; // Example colors
            const borderColors = ['rgba(75, 192, 192, 1)', 'rgba(255, 99, 132, 1)', 'rgba(255, 206, 86, 1)', 'rgba(153, 102, 255, 1)'];

            if (chart) chart.destroy(); // Destroy old chart instance

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'í™•ë¥ ',
                        data: probabilities,
                        backgroundColor: chartColors.slice(0, labels.length),
                        borderColor: borderColors.slice(0, labels.length),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                callback: function(value) {
                                    return (value * 100) + '%';
                                },
                                color: getComputedStyle(document.body).getPropertyValue('--text-color') // Chart.js v3+
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)' // Light grid lines
                            }
                        },
                        x: {
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-color')
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + (context.parsed.y * 100).toFixed(0) + '%';
                                }
                            }
                        }
                    }
                }
            });
            updateChartTheme(); // Apply theme to new chart
        }

        function updateChartTheme() {
            if (!chart) return;
            const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
            const gridColor = document.body.classList.contains('dark-mode') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';

            chart.options.scales.y.ticks.color = textColor;
            chart.options.scales.x.ticks.color = textColor;
            chart.options.scales.y.grid.color = gridColor;
            chart.options.scales.x.grid.color = gridColor;
            
            // Re-render chart to apply new colors
            chart.update();
        }

    </script>
</body>
</html>